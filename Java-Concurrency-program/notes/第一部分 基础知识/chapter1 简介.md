# chapter1 简介

## 1. 并发简史

操作系统的出现使得计算机每次能运行多个程序，并且不同的程序都在单独的进程中运行：操作系统为各个独立执行的进程分配各种资源，包括内存、文件句柄和安全证书等。不同的进程之间也可以通过一些粗粒度的通信机制来交换数据，包括套接字、信号处理器、共享内存、信号量和文件等

操作系统用于实现多个程序的同时执行有以下好处：

- 资源利用率
- 公平性
- 便利性

**线程**允许在同一个进程中同时存在多个程序控制流，并共享进程范围内的资源，例如内存句柄和文件句柄。但每个线程都有各自的程序计数器（PC）、栈以及局部变量等。线程还提供一种直观的分解模式来充分利用多处理器系统中的硬件并行性，而在同一个程序中的多个线程也可以被同时调度到多个CPU中运行

线程，也称轻量级进程。在大多数现代操作系统中，都是以线程为基本调度单位，而非进程。如果没有明确的协同机制，那么线程将彼此独立运行。由于同一个进程中的所有线程都共享进程的内存地址空间，因此这些线程都能访问相同的变量并在同一个堆上分配对象，这就需要实现**更细粒度的数据共享机制**，以免线程间互相干扰

## 2. 线程的优势

- 发挥多处理器的强大能力
- 建模简单
- 异步事件的简化处理
- 响应更灵敏的用户界面

## 3. 线程带来的风险

### 安全性问题

在没有充足同步的情况下，多个线程中的操作执行顺序是不可预测的，甚至产生奇怪的结果

在以下类中说明的是一种常见的并发安全问题：竞态条件（Race Condition）。在多线程环境下，getValue是否返回唯一的值，取决于运行时对线程中操作的交替执行方式。

![image-20220514012112138](https://cdn.jsdelivr.net/gh/Lance-Mai/MyPictureBed/images/image-2022/image-20220514012112138.png)

![image-20220514012631135](https://cdn.jsdelivr.net/gh/Lance-Mai/MyPictureBed/images/image-2022/image-20220514012631135.png)



### 活跃性问题

安全性的含义是：永远不发生糟糕的事情，而活跃性则关注：“某件正确的事情最终会发生”，当某个操作无法继续执行下去的时候，就会发生活跃性问题。

在串行程序中，活跃性问题的形式之一就是无意中造成的无限循环，从而使循环后的代码无法得到执行。

在多线程中则带来一些其他的活跃性问题，如：如果线程A在等待线程B释放其持有的资源，而线程B永远都不释放该资源，那么A就会永久地等待下去。死锁、饥饿、活锁。。。



### 性能问题

多线程程序中不仅存在于单线程程序相同的性能问题，而且还存在由于使用线程而引入的其他性能问题

在多线程程序中，当线程调度器临时挂起活跃线程并运行另一个线程时，就会频繁进行上下文切换操作（Context Switch），开销很大：保存和恢复执行上下文，丢失局部性，并且CPU时间将更多地花在线程调度上而非线程运行上；当线程共享数据时，必须使用**同步机制**，而这些机制往往会抑制某些编译器优化，使内存缓存区中的数据无效，以及增加共享内存总线的同步流量



## 4. 线程无处不在

即使在程序中没有显式地创建线程，但在框架中仍可能创建线程，因此在这些线程中调用代码也必须是线程安全的。

每个java应用程序都会使用线程：当JVM启动时，它将为JVM的内部任务（如垃圾回收、终结操作等）创建后台线程，并创建一个主线程来运行main方法。

当某个框架在应用程序中引入并发性时，通常不可能将并发性仅局限于框架代码，因为框架本身会回调（Callback）应用程序的代码，而这些代码将访问应用程序的状态

- 框架通过在框架线程中调用应用程序代码并将并发性引入到程序中。在代码中将不可避免地访问应用程序状态，因此所有访问这些状态的代码路径必须都是线程安全的

以下给出的模块都将在应用程序之外的线程中调用应用程序的代码

1. Timer
    - Timer类的作用是使任务在稍后的时刻运行，或者运行一次，或者周期性地运行。引入Timer可能会使得串行程序变复杂，因为TimerTask将在Timer管理的线程中执行，而不是由应用程序来管理。如果某个TimerTask访问了应用程序中其他线程访问的数据，那么TimerTask和其他类都必须采用线程安全的方式来访问该数据。**通常实现这个目标最简单的方式是确保TimerTask访问的对象本身是线程安全的，从而能把线程安全性封装在共享对象内部**

2. Servlet 和 JavaServer page（JSP）
    - Servlet框架用于部署网页应用程序以及分发来自HTTP客户端的请求。到达服务器的请求可能会通过一个过滤器链被分发到正确的Servlet或者JSP。每个Servlet都表示一个程序逻辑组件，在高吞吐率的网站中，多个客户端可能同时请求同一个Servlet的服务。在Servlet规范中，Servlet同样需要满足同时被多个线程调用，因此**Servlet需要线程安全**
    - 即使确保每次只有一个线程来调用某个Servlet，但仍然还是需要注意线程安全：Servlet通常会访问其他Servlet共享的信息，例如应用程序中的对象（保存在ServletContext中）或者会话中的对象（保存在每个客户端的HttpSession中）。当一个Servlet访问在多个Servlet或者请求中共享的对象时，必须正确地协同对这些对象的访问，因为多个请求可能在不同的线程中同时访问这些对象。**Servlet和JSP，以及在ServletContext和HttpSession等容器中保存的Servlet过滤器和对象，都必须线程安全**

3. RMI（Remote Method Invocation）
    - 远程方法调用，使代码能够调用在其他JVM中运行的对象。当通过RMI调用某个远程方法时，传递给方法的参数必须被打包（也被称为 列集[Marshaled]）到一个字节流，通过网络传输给远程JVM，然后由远程JVM拆包（也成为 散集[Unmarshaled]）并传递给远程方法
    - 当RMI代码调用远程对象时，这个调用将在哪个线程中执行，我们并不清楚，但肯定不会在本地创建的那个线程中，而是将在一个由RMI管理的线程中调用对象。RMI会创建多少个线程？同一个远程对象上的同一个远程方法会不会在多个RMI线程中被同时调用呢？答案是会的，而这也会引发线程安全问题
    - 远程对象必须注意两个线程安全问题：正确地协同在多个对象中共享的状态，以及对远程对象本身状态的访问（因为同一个对象可能会在多个线程中被访问）。与Servlet相同，RMI对象应该做好被多个线程同时调用的准备，必须确保他们自身的线程安全性

4. Swing 和 AWT